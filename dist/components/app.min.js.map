{"version":3,"sources":["webpack:///components/app.min.js","webpack:///./components/app.js"],"names":["webpackJsonp","module","exports","__webpack_require__","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","call","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","_createClass","defineProperties","target","props","i","length","descriptor","defineProperty","key","protoProps","staticProps","xin","App","_xin$Component","this","getPrototypeOf","apply","arguments","__appSignature","location","window","history","handlers","middlewares","__started","addEventListener","evt","console","error","detail","hashSeparator","reHashSeparator","RegExp","start","pattern","match","str","chunks","split","Error","tokens","re","replace","g","token","push","optRe","slice","route","callback","routeHandler","type","args","__isStatic","result","__routeRegExp","__starting","async","__tryStart","_this2","check","then","executors","mode","checkAndExecute","bind","document","defaultPrevented","nodeName","preventDefault","pushState","url","getAttribute","innerHTML","href","info","__getId","fire","fragment","Promise","resolve","reject","getFragment","running","forEach","handler","name","index","err","executers","promise","middleware","executer","uri","stack","path","options","rootUri","toString","origin","title","decodeURI","pathname","search","back","get","String","observer","Component","define"],"mappings":"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","file":"components/app.min.js","sourcesContent":["webpackJsonp([0],[\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar xin = __webpack_require__(1);\n\t\n\tvar App = function (_xin$Component) {\n\t  _inherits(App, _xin$Component);\n\t\n\t  function App() {\n\t    _classCallCheck(this, App);\n\t\n\t    return _possibleConstructorReturn(this, (App.__proto__ || Object.getPrototypeOf(App)).apply(this, arguments));\n\t  }\n\t\n\t  _createClass(App, [{\n\t    key: 'created',\n\t    value: function created() {\n\t      this.__appSignature = true;\n\t      this.location = window.location;\n\t      this.history = window.history;\n\t\n\t      // default values\n\t      this.handlers = [];\n\t      this.middlewares = [];\n\t\n\t      this.__started = false;\n\t\n\t      this.addEventListener('route-not-found', function (evt) {\n\t        console.error('Route not found: ' + evt.detail);\n\t      });\n\t\n\t      // var originalNotify = this.__notify;\n\t      // this.__notify = function (path, value, oldValue) {\n\t      //   originalNotify.apply(this, arguments);\n\t      //   if (path[0] === '$') {\n\t      //     this.fire('property-sync', {\n\t      //       property: path,\n\t      //       value: value,\n\t      //       oldValue: oldValue,\n\t      //     });\n\t      //   }\n\t      // };\n\t    }\n\t  }, {\n\t    key: '__hashSeparatorChanged',\n\t    value: function __hashSeparatorChanged(hashSeparator) {\n\t      this.reHashSeparator = new RegExp(hashSeparator + '(.*)$');\n\t    }\n\t  }, {\n\t    key: 'attached',\n\t    value: function attached() {\n\t      this.start();\n\t    }\n\t  }, {\n\t    key: '__isStatic',\n\t    value: function __isStatic(pattern) {\n\t      return !pattern.match(/[[{]/);\n\t    }\n\t  }, {\n\t    key: '__routeRegExp',\n\t    value: function __routeRegExp(str) {\n\t      var chunks = str.split('[');\n\t\n\t      if (chunks.length > 2) {\n\t        throw new Error('Invalid use of optional params');\n\t      }\n\t\n\t      var tokens = [];\n\t      var re = chunks[0].replace(/{([^}]+)}/g, function (g, token) {\n\t        tokens.push(token);\n\t        return '([^/]+)';\n\t      }).replace(/\\//g, '\\\\/');\n\t\n\t      var optRe = '';\n\t\n\t      if (chunks[1]) {\n\t        optRe = '(?:' + chunks[1].slice(0, -1).replace(/{([^}]+)}/g, function (g, token) {\n\t          tokens.push(token);\n\t          return '([^/]+)';\n\t        }).replace(/\\//g, '\\\\/') + ')?';\n\t      }\n\t      return [new RegExp('^' + re + optRe + '$'), tokens];\n\t    }\n\t  }, {\n\t    key: 'route',\n\t    value: function route(_route, callback) {\n\t      var routeHandler = {\n\t        route: _route,\n\t        type: 's',\n\t        pattern: null,\n\t        args: [],\n\t        callback: callback\n\t      };\n\t\n\t      if (!this.__isStatic(_route)) {\n\t        routeHandler.type = 'v';\n\t        var result = this.__routeRegExp(_route);\n\t        routeHandler.pattern = result[0];\n\t        routeHandler.args = result[1];\n\t      }\n\t\n\t      this.handlers.push(routeHandler);\n\t\n\t      // when app already on starting state but not accomplished yet will try start when one handler pushed\n\t      if (this.__starting) {\n\t        this.__starting = false;\n\t        this.async(this.__tryStart);\n\t      }\n\t    }\n\t  }, {\n\t    key: 'start',\n\t    value: function start() {\n\t      var _this2 = this;\n\t\n\t      this.__starting = true;\n\t      this.check().then(function (executors) {\n\t        if (executors.length > 0) {\n\t          _this2.__starting = false;\n\t          _this2.__tryStart();\n\t        }\n\t      });\n\t    }\n\t  }, {\n\t    key: '__tryStart',\n\t    value: function __tryStart() {\n\t      if (this.mode === 'history') {\n\t        window.addEventListener('popstate', this.checkAndExecute.bind(this), false);\n\t        document.addEventListener('click', function (evt) {\n\t          if (!evt.defaultPrevented && evt.target.nodeName === 'A' && evt.target.target === '') {\n\t            evt.preventDefault();\n\t            this.history.pushState({\n\t              url: evt.target.getAttribute('href')\n\t            }, evt.target.innerHTML, evt.target.href);\n\t            this.checkAndExecute();\n\t          }\n\t        }.bind(this));\n\t      } else {\n\t        window.addEventListener('hashchange', this.checkAndExecute.bind(this), false);\n\t      }\n\t\n\t      this.checkAndExecute().then(function () {\n\t        console.info('Started    ' + this.__getId());\n\t        this.fire('started');\n\t        this.__started = true;\n\t      }.bind(this));\n\t    }\n\t  }, {\n\t    key: 'isStarted',\n\t    value: function isStarted() {\n\t      return this.__started || false;\n\t    }\n\t  }, {\n\t    key: 'check',\n\t    value: function check(fragment) {\n\t      return new Promise(function (resolve, reject) {\n\t        try {\n\t          fragment = fragment || this.getFragment();\n\t          var running = [];\n\t          this.handlers.forEach(function (handler) {\n\t            if (handler.type === 's') {\n\t              if (fragment === handler.route) {\n\t                running.push({\n\t                  handler: handler,\n\t                  args: {}\n\t                });\n\t                return;\n\t              }\n\t            } else if (handler.type === 'v') {\n\t              // matches is unused\n\t              // var matches = [];\n\t              var result = fragment.match(handler.pattern);\n\t              // if (result) {\n\t              //   matches = result.slice(1);\n\t              // }\n\t\n\t              if (result) {\n\t                var args = {};\n\t\n\t                handler.args.forEach(function (name, index) {\n\t                  args[name] = result[index + 1];\n\t                });\n\t\n\t                running.push({\n\t                  handler: handler,\n\t                  args: args\n\t                });\n\t              }\n\t            }\n\t          });\n\t\n\t          resolve(running);\n\t        } catch (err) {\n\t          reject(err);\n\t        }\n\t      }.bind(this));\n\t    }\n\t  }, {\n\t    key: 'checkAndExecute',\n\t    value: function checkAndExecute() {\n\t      var fragment = this.getFragment();\n\t\n\t      return this.check(fragment).then(function (executers) {\n\t        if (executers.length) {\n\t          var promise = Promise.resolve();\n\t          this.middlewares.forEach(function (middleware) {\n\t            promise = promise.then(function () {\n\t              return middleware.apply(this);\n\t            }.bind(this));\n\t          }.bind(this));\n\t\n\t          return promise.then(function () {\n\t            executers.forEach(function (executer) {\n\t              executer.handler.callback(executer.args);\n\t            });\n\t\n\t            this.fire('navigated', { uri: fragment });\n\t            return executers;\n\t          }.bind(this));\n\t        }\n\t\n\t        this.fire('route-not-found', fragment);\n\t        return [];\n\t      }.bind(this)).catch(function (err) {\n\t        console.error('Uncaught checkAndExecute error, ' + err.stack);\n\t      });\n\t    }\n\t  }, {\n\t    key: 'navigate',\n\t    value: function navigate(path, options) {\n\t      path = path || '/';\n\t      options = options || {};\n\t\n\t      if (this.mode === 'history') {\n\t        var url = this.rootUri + path.toString().replace(/\\/$/, '').replace(/^\\//, '');\n\t        if (this.location.href.replace(this.location.origin, '') !== url) {\n\t          this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);\n\t          this.checkAndExecute();\n\t        }\n\t      } else {\n\t        this.location.href.match(this.reHashSeparator);\n\t        this.location.href = this.location.href.replace(this.reHashSeparator, '') + this.hashSeparator + path;\n\t      }\n\t      return this;\n\t    }\n\t  }, {\n\t    key: 'use',\n\t    value: function use(middleware) {\n\t      this.middlewares.push(middleware);\n\t    }\n\t\n\t    // REMOVED, you can use getFragment()\n\t    // getURI () {\n\t    //   if (this.mode === 'hash') {\n\t    //     return this.location.hash.replace(this.hashSeparator, '') || '/';\n\t    //   } else {\n\t    //     throw new Error('Unimplemented getURI from history mode');\n\t    //   }\n\t    // },\n\t\n\t  }, {\n\t    key: 'getFragment',\n\t    value: function getFragment() {\n\t      var fragment;\n\t      if (this.mode === 'history') {\n\t        fragment = decodeURI(this.location.pathname + this.location.search);\n\t        fragment = fragment.replace(/\\?(.*)$/, '');\n\t        fragment = this.rootUri === '/' ? fragment : fragment.replace(this.rootUri, '');\n\t      } else {\n\t        var match = this.location.href.match(this.reHashSeparator);\n\t        fragment = match ? match[1] : '';\n\t      }\n\t\n\t      return '/' + fragment.toString().replace(/\\/$/, '').replace(/^\\//, '');\n\t    }\n\t  }, {\n\t    key: '$back',\n\t    value: function $back(evt) {\n\t      evt.preventDefault();\n\t      this.history.back();\n\t    }\n\t  }, {\n\t    key: 'props',\n\t    get: function get() {\n\t      return {\n\t        mode: {\n\t          type: String,\n\t          value: 'hash'\n\t        },\n\t\n\t        rootUri: {\n\t          type: String,\n\t          value: '/'\n\t        },\n\t\n\t        hashSeparator: {\n\t          type: String,\n\t          value: '#!',\n\t          observer: '__hashSeparatorChanged'\n\t        }\n\t      };\n\t    }\n\t  }]);\n\t\n\t  return App;\n\t}(xin.Component);\n\t\n\txin.define('xin-app', App);\n\t\n\txin.App = App;\n\t\n\tmodule.exports = App;\n\n/***/ }\n]);\n\n\n/** WEBPACK FOOTER **\n ** components/app.min.js\n **/","const xin = require('../index');\n\nclass App extends xin.Component {\n  get props () {\n    return {\n      mode: {\n        type: String,\n        value: 'hash',\n      },\n\n      rootUri: {\n        type: String,\n        value: '/',\n      },\n\n      hashSeparator: {\n        type: String,\n        value: '#!',\n        observer: '__hashSeparatorChanged',\n      },\n    };\n  }\n\n  created () {\n    this.__appSignature = true;\n    this.location = window.location;\n    this.history = window.history;\n\n    // default values\n    this.handlers = [];\n    this.middlewares = [];\n\n    this.__started = false;\n\n    this.addEventListener('route-not-found', function (evt) {\n      console.error('Route not found: ' + evt.detail);\n    });\n\n    // var originalNotify = this.__notify;\n    // this.__notify = function (path, value, oldValue) {\n    //   originalNotify.apply(this, arguments);\n    //   if (path[0] === '$') {\n    //     this.fire('property-sync', {\n    //       property: path,\n    //       value: value,\n    //       oldValue: oldValue,\n    //     });\n    //   }\n    // };\n  }\n\n  __hashSeparatorChanged (hashSeparator) {\n    this.reHashSeparator = new RegExp(hashSeparator + '(.*)$');\n  }\n\n  attached () {\n    this.start();\n  }\n\n  __isStatic (pattern) {\n    return !pattern.match(/[[{]/);\n  }\n\n  __routeRegExp (str) {\n    var chunks = str.split('[');\n\n    if (chunks.length > 2) {\n      throw new Error('Invalid use of optional params');\n    }\n\n    var tokens = [];\n    var re = chunks[0].replace(/{([^}]+)}/g, function (g, token) {\n      tokens.push(token);\n      return '([^/]+)';\n    }).replace(/\\//g, '\\\\/');\n\n    var optRe = '';\n\n    if (chunks[1]) {\n      optRe = '(?:' + chunks[1].slice(0, -1).replace(/{([^}]+)}/g, function (g, token) {\n        tokens.push(token);\n        return '([^/]+)';\n      }).replace(/\\//g, '\\\\/') + ')?';\n    }\n    return [new RegExp('^' + re + optRe + '$'), tokens];\n  }\n\n  route (route, callback) {\n    var routeHandler = {\n      route: route,\n      type: 's',\n      pattern: null,\n      args: [],\n      callback: callback,\n    };\n\n    if (!this.__isStatic(route)) {\n      routeHandler.type = 'v';\n      var result = this.__routeRegExp(route);\n      routeHandler.pattern = result[0];\n      routeHandler.args = result[1];\n    }\n\n    this.handlers.push(routeHandler);\n\n    // when app already on starting state but not accomplished yet will try start when one handler pushed\n    if (this.__starting) {\n      this.__starting = false;\n      this.async(this.__tryStart);\n    }\n  }\n\n  start () {\n    this.__starting = true;\n    this.check().then(executors => {\n      if (executors.length > 0) {\n        this.__starting = false;\n        this.__tryStart();\n      }\n    });\n  }\n\n  __tryStart () {\n    if (this.mode === 'history') {\n      window.addEventListener('popstate', this.checkAndExecute.bind(this), false);\n      document.addEventListener('click', function (evt) {\n        if (!evt.defaultPrevented && evt.target.nodeName === 'A' && evt.target.target === '') {\n          evt.preventDefault();\n          this.history.pushState({\n            url: evt.target.getAttribute('href'),\n          }, evt.target.innerHTML, evt.target.href);\n          this.checkAndExecute();\n        }\n      }.bind(this));\n    } else {\n      window.addEventListener('hashchange', this.checkAndExecute.bind(this), false);\n    }\n\n    this.checkAndExecute()\n      .then(function () {\n        console.info('Started    ' + this.__getId());\n        this.fire('started');\n        this.__started = true;\n      }.bind(this));\n  }\n\n  isStarted () {\n    return this.__started || false;\n  }\n\n  check (fragment) {\n    return new Promise(function (resolve, reject) {\n      try {\n        fragment = fragment || this.getFragment();\n        var running = [];\n        this.handlers.forEach(function (handler) {\n          if (handler.type === 's') {\n            if (fragment === handler.route) {\n              running.push({\n                handler: handler,\n                args: {},\n              });\n              return;\n            }\n          } else if (handler.type === 'v') {\n            // matches is unused\n            // var matches = [];\n            var result = fragment.match(handler.pattern);\n            // if (result) {\n            //   matches = result.slice(1);\n            // }\n\n            if (result) {\n              var args = {};\n\n              handler.args.forEach(function (name, index) {\n                args[name] = result[index + 1];\n              });\n\n              running.push({\n                handler: handler,\n                args: args,\n              });\n            }\n          }\n        });\n\n        resolve(running);\n      } catch (err) {\n        reject(err);\n      }\n    }.bind(this));\n  }\n\n  checkAndExecute () {\n    var fragment = this.getFragment();\n\n    return this.check(fragment)\n      .then(function (executers) {\n        if (executers.length) {\n          var promise = Promise.resolve();\n          this.middlewares.forEach(function (middleware) {\n            promise = promise.then(function () {\n              return middleware.apply(this);\n            }.bind(this));\n          }.bind(this));\n\n          return promise.then(function () {\n            executers.forEach(function (executer) {\n              executer.handler.callback(executer.args);\n            });\n\n            this.fire('navigated', {uri: fragment});\n            return executers;\n          }.bind(this));\n        }\n\n        this.fire('route-not-found', fragment);\n        return [];\n      }.bind(this))\n      .catch(function (err) {\n        console.error('Uncaught checkAndExecute error, ' + err.stack);\n      });\n  }\n\n  navigate (path, options) {\n    path = path || '/';\n    options = options || {};\n\n    if (this.mode === 'history') {\n      var url = this.rootUri + path.toString().replace(/\\/$/, '').replace(/^\\//, '');\n      if (this.location.href.replace(this.location.origin, '') !== url) {\n        this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);\n        this.checkAndExecute();\n      }\n    } else {\n      this.location.href.match(this.reHashSeparator);\n      this.location.href = this.location.href.replace(this.reHashSeparator, '') + this.hashSeparator + path;\n    }\n    return this;\n  }\n\n  use (middleware) {\n    this.middlewares.push(middleware);\n  }\n\n  // REMOVED, you can use getFragment()\n  // getURI () {\n  //   if (this.mode === 'hash') {\n  //     return this.location.hash.replace(this.hashSeparator, '') || '/';\n  //   } else {\n  //     throw new Error('Unimplemented getURI from history mode');\n  //   }\n  // },\n\n  getFragment () {\n    var fragment;\n    if (this.mode === 'history') {\n      fragment = decodeURI(this.location.pathname + this.location.search);\n      fragment = fragment.replace(/\\?(.*)$/, '');\n      fragment = this.rootUri === '/' ? fragment : fragment.replace(this.rootUri, '');\n    } else {\n      var match = this.location.href.match(this.reHashSeparator);\n      fragment = match ? match[1] : '';\n    }\n\n    return '/' + fragment.toString().replace(/\\/$/, '').replace(/^\\//, '');\n  }\n\n  $back (evt) {\n    evt.preventDefault();\n    this.history.back();\n  }\n}\n\nxin.define('xin-app', App);\n\nxin.App = App;\n\nmodule.exports = App;\n\n\n\n/** WEBPACK FOOTER **\n ** ./components/app.js\n **/"],"sourceRoot":""}