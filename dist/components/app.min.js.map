{"version":3,"sources":["webpack:///components/app.min.js","webpack:///./components/app.js"],"names":["webpackJsonp","module","exports","__webpack_require__","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","call","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","_createClass","defineProperties","target","props","i","length","descriptor","defineProperty","key","protoProps","staticProps","xin","App","_xin$Component","this","getPrototypeOf","apply","arguments","title","document","__appSignature","location","window","history","handlers","middlewares","__started","addEventListener","evt","console","error","detail","hashSeparator","reHashSeparator","RegExp","start","pattern","match","str","chunks","split","Error","tokens","re","replace","g","token","push","optRe","slice","route","callback","routeHandler","type","args","__isStatic","result","__routeRegExp","__starting","async","__tryStart","_this2","check","then","executors","mode","checkAndExecute","bind","defaultPrevented","nodeName","preventDefault","pushState","url","getAttribute","innerHTML","href","info","__getId","fire","fragment","Promise","resolve","reject","getFragment","running","forEach","handler","name","index","err","executers","promise","middleware","executer","uri","stack","path","options","rootUri","toString","origin","decodeURI","pathname","search","back","get","String","observer","Component","define"],"mappings":"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","file":"components/app.min.js","sourcesContent":["webpackJsonp([0],[\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar xin = __webpack_require__(1);\n\t\n\tvar App = function (_xin$Component) {\n\t  _inherits(App, _xin$Component);\n\t\n\t  function App() {\n\t    _classCallCheck(this, App);\n\t\n\t    return _possibleConstructorReturn(this, (App.__proto__ || Object.getPrototypeOf(App)).apply(this, arguments));\n\t  }\n\t\n\t  _createClass(App, [{\n\t    key: '_titleChanged',\n\t    value: function _titleChanged(title) {\n\t      document.title = title;\n\t    }\n\t  }, {\n\t    key: 'created',\n\t    value: function created() {\n\t      this.__appSignature = true;\n\t      this.location = window.location;\n\t      this.history = window.history;\n\t\n\t      // default values\n\t      this.handlers = [];\n\t      this.middlewares = [];\n\t\n\t      this.__started = false;\n\t\n\t      this.addEventListener('route-not-found', function (evt) {\n\t        console.error('Route not found: ' + evt.detail);\n\t      });\n\t\n\t      // var originalNotify = this.__notify;\n\t      // this.__notify = function (path, value, oldValue) {\n\t      //   originalNotify.apply(this, arguments);\n\t      //   if (path[0] === '$') {\n\t      //     this.fire('property-sync', {\n\t      //       property: path,\n\t      //       value: value,\n\t      //       oldValue: oldValue,\n\t      //     });\n\t      //   }\n\t      // };\n\t    }\n\t  }, {\n\t    key: '_hashSeparatorChanged',\n\t    value: function _hashSeparatorChanged(hashSeparator) {\n\t      this.reHashSeparator = new RegExp(hashSeparator + '(.*)$');\n\t    }\n\t  }, {\n\t    key: 'attached',\n\t    value: function attached() {\n\t      this.start();\n\t    }\n\t  }, {\n\t    key: '__isStatic',\n\t    value: function __isStatic(pattern) {\n\t      return !pattern.match(/[[{]/);\n\t    }\n\t  }, {\n\t    key: '__routeRegExp',\n\t    value: function __routeRegExp(str) {\n\t      var chunks = str.split('[');\n\t\n\t      if (chunks.length > 2) {\n\t        throw new Error('Invalid use of optional params');\n\t      }\n\t\n\t      var tokens = [];\n\t      var re = chunks[0].replace(/{([^}]+)}/g, function (g, token) {\n\t        tokens.push(token);\n\t        return '([^/]+)';\n\t      }).replace(/\\//g, '\\\\/');\n\t\n\t      var optRe = '';\n\t\n\t      if (chunks[1]) {\n\t        optRe = '(?:' + chunks[1].slice(0, -1).replace(/{([^}]+)}/g, function (g, token) {\n\t          tokens.push(token);\n\t          return '([^/]+)';\n\t        }).replace(/\\//g, '\\\\/') + ')?';\n\t      }\n\t      return [new RegExp('^' + re + optRe + '$'), tokens];\n\t    }\n\t  }, {\n\t    key: 'route',\n\t    value: function route(_route, callback) {\n\t      var routeHandler = {\n\t        route: _route,\n\t        type: 's',\n\t        pattern: null,\n\t        args: [],\n\t        callback: callback\n\t      };\n\t\n\t      if (!this.__isStatic(_route)) {\n\t        routeHandler.type = 'v';\n\t        var result = this.__routeRegExp(_route);\n\t        routeHandler.pattern = result[0];\n\t        routeHandler.args = result[1];\n\t      }\n\t\n\t      this.handlers.push(routeHandler);\n\t\n\t      // when app already on starting state but not accomplished yet will try start when one handler pushed\n\t      if (this.__starting) {\n\t        this.__starting = false;\n\t        this.async(this.__tryStart);\n\t      }\n\t    }\n\t  }, {\n\t    key: 'start',\n\t    value: function start() {\n\t      var _this2 = this;\n\t\n\t      this.__starting = true;\n\t      this.check().then(function (executors) {\n\t        if (executors.length > 0) {\n\t          _this2.__starting = false;\n\t          _this2.__tryStart();\n\t        }\n\t      });\n\t    }\n\t  }, {\n\t    key: '__tryStart',\n\t    value: function __tryStart() {\n\t      if (this.mode === 'history') {\n\t        window.addEventListener('popstate', this.checkAndExecute.bind(this), false);\n\t        document.addEventListener('click', function (evt) {\n\t          if (!evt.defaultPrevented && evt.target.nodeName === 'A' && evt.target.target === '') {\n\t            evt.preventDefault();\n\t            this.history.pushState({\n\t              url: evt.target.getAttribute('href')\n\t            }, evt.target.innerHTML, evt.target.href);\n\t            this.checkAndExecute();\n\t          }\n\t        }.bind(this));\n\t      } else {\n\t        window.addEventListener('hashchange', this.checkAndExecute.bind(this), false);\n\t      }\n\t\n\t      this.checkAndExecute().then(function () {\n\t        console.info('Started    ' + this.__getId());\n\t        this.fire('started');\n\t        this.__started = true;\n\t      }.bind(this));\n\t    }\n\t  }, {\n\t    key: 'isStarted',\n\t    value: function isStarted() {\n\t      return this.__started || false;\n\t    }\n\t  }, {\n\t    key: 'check',\n\t    value: function check(fragment) {\n\t      return new Promise(function (resolve, reject) {\n\t        try {\n\t          fragment = fragment || this.getFragment();\n\t          var running = [];\n\t          this.handlers.forEach(function (handler) {\n\t            if (handler.type === 's') {\n\t              if (fragment === handler.route) {\n\t                running.push({\n\t                  handler: handler,\n\t                  args: {}\n\t                });\n\t                return;\n\t              }\n\t            } else if (handler.type === 'v') {\n\t              // matches is unused\n\t              // var matches = [];\n\t              var result = fragment.match(handler.pattern);\n\t              // if (result) {\n\t              //   matches = result.slice(1);\n\t              // }\n\t\n\t              if (result) {\n\t                var args = {};\n\t\n\t                handler.args.forEach(function (name, index) {\n\t                  args[name] = result[index + 1];\n\t                });\n\t\n\t                running.push({\n\t                  handler: handler,\n\t                  args: args\n\t                });\n\t              }\n\t            }\n\t          });\n\t\n\t          resolve(running);\n\t        } catch (err) {\n\t          reject(err);\n\t        }\n\t      }.bind(this));\n\t    }\n\t  }, {\n\t    key: 'checkAndExecute',\n\t    value: function checkAndExecute() {\n\t      var fragment = this.getFragment();\n\t\n\t      return this.check(fragment).then(function (executers) {\n\t        if (executers.length) {\n\t          var promise = Promise.resolve();\n\t          this.middlewares.forEach(function (middleware) {\n\t            promise = promise.then(function () {\n\t              return middleware.apply(this);\n\t            }.bind(this));\n\t          }.bind(this));\n\t\n\t          return promise.then(function () {\n\t            executers.forEach(function (executer) {\n\t              executer.handler.callback(executer.args);\n\t            });\n\t\n\t            this.fire('navigated', { uri: fragment });\n\t            return executers;\n\t          }.bind(this));\n\t        }\n\t\n\t        this.fire('route-not-found', fragment);\n\t        return [];\n\t      }.bind(this)).catch(function (err) {\n\t        console.error('Uncaught checkAndExecute error, ' + err.stack);\n\t      });\n\t    }\n\t  }, {\n\t    key: 'navigate',\n\t    value: function navigate(path, options) {\n\t      path = path || '/';\n\t      options = options || {};\n\t\n\t      if (this.mode === 'history') {\n\t        var url = this.rootUri + path.toString().replace(/\\/$/, '').replace(/^\\//, '');\n\t        if (this.location.href.replace(this.location.origin, '') !== url) {\n\t          this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);\n\t          this.checkAndExecute();\n\t        }\n\t      } else {\n\t        this.location.href.match(this.reHashSeparator);\n\t        this.location.href = this.location.href.replace(this.reHashSeparator, '') + this.hashSeparator + path;\n\t      }\n\t      return this;\n\t    }\n\t  }, {\n\t    key: 'use',\n\t    value: function use(middleware) {\n\t      this.middlewares.push(middleware);\n\t    }\n\t\n\t    // REMOVED, you can use getFragment()\n\t    // getURI () {\n\t    //   if (this.mode === 'hash') {\n\t    //     return this.location.hash.replace(this.hashSeparator, '') || '/';\n\t    //   } else {\n\t    //     throw new Error('Unimplemented getURI from history mode');\n\t    //   }\n\t    // },\n\t\n\t  }, {\n\t    key: 'getFragment',\n\t    value: function getFragment() {\n\t      var fragment;\n\t      if (this.mode === 'history') {\n\t        fragment = decodeURI(this.location.pathname + this.location.search);\n\t        fragment = fragment.replace(/\\?(.*)$/, '');\n\t        fragment = this.rootUri === '/' ? fragment : fragment.replace(this.rootUri, '');\n\t      } else {\n\t        var match = this.location.href.match(this.reHashSeparator);\n\t        fragment = match ? match[1] : '';\n\t      }\n\t\n\t      return '/' + fragment.toString().replace(/\\/$/, '').replace(/^\\//, '');\n\t    }\n\t  }, {\n\t    key: '$back',\n\t    value: function $back(evt) {\n\t      evt.preventDefault();\n\t      this.history.back();\n\t    }\n\t  }, {\n\t    key: 'props',\n\t    get: function get() {\n\t      return {\n\t        title: {\n\t          type: String,\n\t          value: 'Application',\n\t          observer: '_titleChanged'\n\t        },\n\t\n\t        mode: {\n\t          type: String,\n\t          value: 'hash'\n\t        },\n\t\n\t        rootUri: {\n\t          type: String,\n\t          value: '/'\n\t        },\n\t\n\t        hashSeparator: {\n\t          type: String,\n\t          value: '#!',\n\t          observer: '_hashSeparatorChanged'\n\t        }\n\t      };\n\t    }\n\t  }]);\n\t\n\t  return App;\n\t}(xin.Component);\n\t\n\txin.define('xin-app', App);\n\t\n\txin.App = App;\n\t\n\tmodule.exports = App;\n\n/***/ }\n]);\n\n\n/** WEBPACK FOOTER **\n ** components/app.min.js\n **/","const xin = require('../src');\n\nclass App extends xin.Component {\n  get props () {\n    return {\n      title: {\n        type: String,\n        value: 'Application',\n        observer: '_titleChanged',\n      },\n\n      mode: {\n        type: String,\n        value: 'hash',\n      },\n\n      rootUri: {\n        type: String,\n        value: '/',\n      },\n\n      hashSeparator: {\n        type: String,\n        value: '#!',\n        observer: '_hashSeparatorChanged',\n      },\n    };\n  }\n\n  _titleChanged (title) {\n    document.title = title;\n  }\n\n  created () {\n    this.__appSignature = true;\n    this.location = window.location;\n    this.history = window.history;\n\n    // default values\n    this.handlers = [];\n    this.middlewares = [];\n\n    this.__started = false;\n\n    this.addEventListener('route-not-found', function (evt) {\n      console.error('Route not found: ' + evt.detail);\n    });\n\n    // var originalNotify = this.__notify;\n    // this.__notify = function (path, value, oldValue) {\n    //   originalNotify.apply(this, arguments);\n    //   if (path[0] === '$') {\n    //     this.fire('property-sync', {\n    //       property: path,\n    //       value: value,\n    //       oldValue: oldValue,\n    //     });\n    //   }\n    // };\n  }\n\n  _hashSeparatorChanged (hashSeparator) {\n    this.reHashSeparator = new RegExp(hashSeparator + '(.*)$');\n  }\n\n  attached () {\n    this.start();\n  }\n\n  __isStatic (pattern) {\n    return !pattern.match(/[[{]/);\n  }\n\n  __routeRegExp (str) {\n    var chunks = str.split('[');\n\n    if (chunks.length > 2) {\n      throw new Error('Invalid use of optional params');\n    }\n\n    var tokens = [];\n    var re = chunks[0].replace(/{([^}]+)}/g, function (g, token) {\n      tokens.push(token);\n      return '([^/]+)';\n    }).replace(/\\//g, '\\\\/');\n\n    var optRe = '';\n\n    if (chunks[1]) {\n      optRe = '(?:' + chunks[1].slice(0, -1).replace(/{([^}]+)}/g, function (g, token) {\n        tokens.push(token);\n        return '([^/]+)';\n      }).replace(/\\//g, '\\\\/') + ')?';\n    }\n    return [new RegExp('^' + re + optRe + '$'), tokens];\n  }\n\n  route (route, callback) {\n    var routeHandler = {\n      route: route,\n      type: 's',\n      pattern: null,\n      args: [],\n      callback: callback,\n    };\n\n    if (!this.__isStatic(route)) {\n      routeHandler.type = 'v';\n      var result = this.__routeRegExp(route);\n      routeHandler.pattern = result[0];\n      routeHandler.args = result[1];\n    }\n\n    this.handlers.push(routeHandler);\n\n    // when app already on starting state but not accomplished yet will try start when one handler pushed\n    if (this.__starting) {\n      this.__starting = false;\n      this.async(this.__tryStart);\n    }\n  }\n\n  start () {\n    this.__starting = true;\n    this.check().then(executors => {\n      if (executors.length > 0) {\n        this.__starting = false;\n        this.__tryStart();\n      }\n    });\n  }\n\n  __tryStart () {\n    if (this.mode === 'history') {\n      window.addEventListener('popstate', this.checkAndExecute.bind(this), false);\n      document.addEventListener('click', function (evt) {\n        if (!evt.defaultPrevented && evt.target.nodeName === 'A' && evt.target.target === '') {\n          evt.preventDefault();\n          this.history.pushState({\n            url: evt.target.getAttribute('href'),\n          }, evt.target.innerHTML, evt.target.href);\n          this.checkAndExecute();\n        }\n      }.bind(this));\n    } else {\n      window.addEventListener('hashchange', this.checkAndExecute.bind(this), false);\n    }\n\n    this.checkAndExecute()\n      .then(function () {\n        console.info('Started    ' + this.__getId());\n        this.fire('started');\n        this.__started = true;\n      }.bind(this));\n  }\n\n  isStarted () {\n    return this.__started || false;\n  }\n\n  check (fragment) {\n    return new Promise(function (resolve, reject) {\n      try {\n        fragment = fragment || this.getFragment();\n        var running = [];\n        this.handlers.forEach(function (handler) {\n          if (handler.type === 's') {\n            if (fragment === handler.route) {\n              running.push({\n                handler: handler,\n                args: {},\n              });\n              return;\n            }\n          } else if (handler.type === 'v') {\n            // matches is unused\n            // var matches = [];\n            var result = fragment.match(handler.pattern);\n            // if (result) {\n            //   matches = result.slice(1);\n            // }\n\n            if (result) {\n              var args = {};\n\n              handler.args.forEach(function (name, index) {\n                args[name] = result[index + 1];\n              });\n\n              running.push({\n                handler: handler,\n                args: args,\n              });\n            }\n          }\n        });\n\n        resolve(running);\n      } catch (err) {\n        reject(err);\n      }\n    }.bind(this));\n  }\n\n  checkAndExecute () {\n    var fragment = this.getFragment();\n\n    return this.check(fragment)\n      .then(function (executers) {\n        if (executers.length) {\n          var promise = Promise.resolve();\n          this.middlewares.forEach(function (middleware) {\n            promise = promise.then(function () {\n              return middleware.apply(this);\n            }.bind(this));\n          }.bind(this));\n\n          return promise.then(function () {\n            executers.forEach(function (executer) {\n              executer.handler.callback(executer.args);\n            });\n\n            this.fire('navigated', {uri: fragment});\n            return executers;\n          }.bind(this));\n        }\n\n        this.fire('route-not-found', fragment);\n        return [];\n      }.bind(this))\n      .catch(function (err) {\n        console.error('Uncaught checkAndExecute error, ' + err.stack);\n      });\n  }\n\n  navigate (path, options) {\n    path = path || '/';\n    options = options || {};\n\n    if (this.mode === 'history') {\n      var url = this.rootUri + path.toString().replace(/\\/$/, '').replace(/^\\//, '');\n      if (this.location.href.replace(this.location.origin, '') !== url) {\n        this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);\n        this.checkAndExecute();\n      }\n    } else {\n      this.location.href.match(this.reHashSeparator);\n      this.location.href = this.location.href.replace(this.reHashSeparator, '') + this.hashSeparator + path;\n    }\n    return this;\n  }\n\n  use (middleware) {\n    this.middlewares.push(middleware);\n  }\n\n  // REMOVED, you can use getFragment()\n  // getURI () {\n  //   if (this.mode === 'hash') {\n  //     return this.location.hash.replace(this.hashSeparator, '') || '/';\n  //   } else {\n  //     throw new Error('Unimplemented getURI from history mode');\n  //   }\n  // },\n\n  getFragment () {\n    var fragment;\n    if (this.mode === 'history') {\n      fragment = decodeURI(this.location.pathname + this.location.search);\n      fragment = fragment.replace(/\\?(.*)$/, '');\n      fragment = this.rootUri === '/' ? fragment : fragment.replace(this.rootUri, '');\n    } else {\n      var match = this.location.href.match(this.reHashSeparator);\n      fragment = match ? match[1] : '';\n    }\n\n    return '/' + fragment.toString().replace(/\\/$/, '').replace(/^\\//, '');\n  }\n\n  $back (evt) {\n    evt.preventDefault();\n    this.history.back();\n  }\n}\n\nxin.define('xin-app', App);\n\nxin.App = App;\n\nmodule.exports = App;\n\n\n\n/** WEBPACK FOOTER **\n ** ./components/app.js\n **/"],"sourceRoot":""}